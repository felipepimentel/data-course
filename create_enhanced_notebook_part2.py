import json

# Carregar notebook base
with open('analyze_people_data_enhanced.ipynb', 'r', encoding='utf-8') as f:
    notebook = json.load(f)

# Adicionar c√©lulas para carregamento de dados
data_loading_cells = [
  {
   'cell_type': 'markdown',
   'metadata': {},
   'source': ['## üìÇ Carregamento dos Dados\n', 
              'Configure o caminho para o diret√≥rio de dados e carregue as avalia√ß√µes.']
  },
  {
   'cell_type': 'code',
   'execution_count': None,
   'metadata': {},
   'outputs': [],
   'source': ['# Configurar caminho para diret√≥rio de dados\n', 
              'DATA_DIR = "test_data"  # Altere para o caminho dos seus dados reais\n', 
              '\n', 
              '# Encontrar arquivos no padr√£o <pessoa>/<ano>/resultado.json\n', 
              'files = scan_directory(DATA_DIR, "*/*/resultado.json")\n', 
              'print(f"Encontrados {len(files)} arquivos de resultados:")\n', 
              'for f in files:\n', 
              '    print(f"  - {f}")\n',
              '\n',
              '# Carregar todos os dados em um DataFrame\n',
              'df_evaluations = load_all_evaluations(DATA_DIR)\n',
              '\n',
              'if df_evaluations.empty:\n',
              '    display(HTML(\'<div class="alert-danger">Nenhum dado de avalia√ß√£o encontrado. Verifique o caminho especificado.</div>\'))\n',
              'else:\n',
              '    display(HTML(f\'<div class="alert-success">Carregados dados de {df_evaluations["pessoa"].nunique()} pessoas em {df_evaluations["ano"].nunique()} anos.</div>\'))\n',
              '    display(df_evaluations.head())'
              ]
  },
  {
   'cell_type': 'markdown',
   'metadata': {},
   'source': ['## üìä Vis√£o Geral dos Dados\n', 
              'Resumo estat√≠stico e an√°lise explorat√≥ria das avalia√ß√µes.']
  },
  {
   'cell_type': 'code',
   'execution_count': None,
   'metadata': {},
   'outputs': [],
   'source': ['if not df_evaluations.empty:\n',
              '    # Estat√≠sticas gerais\n',
              '    stats = {\n',
              '        "Quantidade de pessoas": df_evaluations["pessoa"].nunique(),\n',
              '        "Anos de avalia√ß√£o": sorted(df_evaluations["ano"].unique()),\n',
              '        "Direcionadores": df_evaluations["direcionador"].nunique(),\n',
              '        "Comportamentos": df_evaluations["comportamento"].nunique(),\n',
              '        "Tipos de avaliadores": df_evaluations["avaliador"].nunique(),\n',
              '        "Score m√©dio individual": df_evaluations["score_colaborador"].mean(),\n',
              '        "Score m√©dio grupo": df_evaluations["score_grupo"].mean(),\n',
              '        "Diferen√ßa m√©dia": df_evaluations["diferenca"].mean()\n',
              '    }\n',
              '    \n',
              '    # Exibir estat√≠sticas em uma tabela HTML formatada\n',
              '    html_stats = "<table>"\n',
              '    html_stats += "<tr><th>M√©trica</th><th>Valor</th></tr>"\n',
              '    for key, value in stats.items():\n',
              '        if isinstance(value, float):\n',
              '            value_str = f"{value:.2f}"\n',
              '        elif isinstance(value, list):\n',
              '            value_str = ", ".join(str(v) for v in value)\n',
              '        else:\n',
              '            value_str = str(value)\n',
              '        html_stats += f"<tr><td>{key}</td><td>{value_str}</td></tr>"\n',
              '    html_stats += "</table>"\n',
              '    \n',
              '    display(HTML(html_stats))\n',
              '    \n',
              '    # Distribui√ß√£o dos scores\n',
              '    fig = make_subplots(rows=1, cols=2, subplot_titles=["Distribui√ß√£o de Scores Individual", "Distribui√ß√£o de Diferen√ßas"])\n',
              '    \n',
              '    fig.add_trace(\n',
              '        go.Histogram(\n',
              '            x=df_evaluations["score_colaborador"], \n',
              '            nbinsx=20, \n',
              '            marker_color=COLORS[0],\n',
              '            name="Score Individual"\n',
              '        ),\n',
              '        row=1, col=1\n',
              '    )\n',
              '    \n',
              '    fig.add_trace(\n',
              '        go.Histogram(\n',
              '            x=df_evaluations["diferenca"], \n',
              '            nbinsx=20, \n',
              '            marker_color=COLORS[1],\n',
              '            name="Diferen√ßa vs Grupo"\n',
              '        ),\n',
              '        row=1, col=2\n',
              '    )\n',
              '    \n',
              '    fig.update_layout(\n',
              '        height=400,\n',
              '        title_text="Distribui√ß√£o de Scores e Diferen√ßas",\n',
              '        showlegend=True\n',
              '    )\n',
              '    \n',
              '    fig.show()'
             ]
  },
  {
   'cell_type': 'markdown',
   'metadata': {},
   'source': ['## üßÆ An√°lise por Pessoa\n', 
              'Compara√ß√£o de desempenho entre diferentes pessoas avaliadas.']
  },
  {
   'cell_type': 'code',
   'execution_count': None,
   'metadata': {},
   'outputs': [],
   'source': ['if not df_evaluations.empty:\n',
              '    # Scores m√©dios por pessoa\n',
              '    person_scores = df_evaluations.groupby("pessoa").agg(\n',
              '        score_medio=("score_colaborador", "mean"),\n',
              '        diferenca_media=("diferenca", "mean"),\n',
              '        score_minimo=("score_colaborador", "min"),\n',
              '        score_maximo=("score_colaborador", "max"),\n',
              '        contagem=("score_colaborador", "count")\n',
              '    ).reset_index()\n',
              '    \n',
              '    # Plotar gr√°fico de barras comparativo\n',
              '    fig = px.bar(\n',
              '        person_scores,\n',
              '        x="pessoa",\n',
              '        y="score_medio",\n',
              '        error_y=person_scores["score_maximo"] - person_scores["score_medio"],\n',
              '        error_y_minus=person_scores["score_medio"] - person_scores["score_minimo"],\n',
              '        color="diferenca_media",\n',
              '        size="contagem",\n',
              '        hover_data=["score_minimo", "score_maximo", "contagem"],\n',
              '        color_continuous_scale=px.colors.diverging.RdBu,\n',
              '        color_continuous_midpoint=0,\n',
              '        title="Score M√©dio por Pessoa (com barras de erro min-max)",\n',
              '        labels={\n',
              '            "pessoa": "Pessoa",\n',
              '            "score_medio": "Score M√©dio",\n',
              '            "diferenca_media": "Diferen√ßa vs Grupo",\n',
              '            "score_minimo": "Score M√≠nimo",\n',
              '            "score_maximo": "Score M√°ximo",\n',
              '            "contagem": "Quantidade de Avalia√ß√µes"\n',
              '        }\n',
              '    )\n',
              '    \n',
              '    fig.update_layout(\n',
              '        height=500,\n',
              '        xaxis_title="Pessoa",\n',
              '        yaxis_title="Score M√©dio (0-4)",\n',
              '        yaxis_range=[0, 4],\n',
              '        coloraxis_colorbar=dict(title="Diferen√ßa vs Grupo")\n',
              '    )\n',
              '    \n',
              '    fig.show()\n',
              '    \n',
              '    # Tabela detalhada por pessoa\n',
              '    person_scores = person_scores.sort_values("score_medio", ascending=False)\n',
              '    display(person_scores.style\n',
              '           .format({"score_medio": "{:.2f}", "diferenca_media": "{:.2f}", \n',
              '                   "score_minimo": "{:.2f}", "score_maximo": "{:.2f}"})\n',
              '           .background_gradient(cmap="RdYlGn", subset=["score_medio"])\n',
              '           .background_gradient(cmap="RdBu", subset=["diferenca_media"])\n',
              '          )'
              ]
  }
]

# Adicionar as c√©lulas ao notebook
for cell in data_loading_cells:
    notebook['cells'].append(cell)

# Salvar notebook atualizado
with open('analyze_people_data_enhanced.ipynb', 'w', encoding='utf-8') as f:
    json.dump(notebook, f, indent=1)

print('Parte 2 do notebook aprimorado adicionada com sucesso!') 